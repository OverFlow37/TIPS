금요일에 설명이 조금 부족했던 부분이 있었던 것 같아서 과목 평가 전에 스스로 리마인드할 겸, 알고리즘 문제 풀이 관련 팁을 상세하게 남기겠습니다.

### 목차
1. 설계의 중요성 (설계를 해야 하는 이유)
2. 설계 순서
3. 구현 순서
4. 알고리즘 선택 기준

---

### 1. 설계의 중요성 (설계를 해야 하는 이유)
문제 풀이를 할 때 설계를 해야 하는 이유는 여러 가지가 있지만, 특히 저희처럼 베이스가 부족한 비전공자들은 **뭘 하고 있는지 까먹지 않기 위해** 설계가 꼭 필요하다고 생각합니다. 모두들 테스트를 거쳐 SSAFY에 들어오셨고 저보다 똑똑한 분들이지만, 문제 풀이가 쉽지 않은 이유는 코딩 자체가 아직 익숙하지 않기 때문입니다. 구현 과정에서 실수도 잦고 파이썬 자체도 아직 어색하지만, 꼼꼼한 설계를 통해 이를 보완할 수 있습니다. 지금부터 시행착오를 줄일 수 있는 설계 과정을 설명드리겠습니다.

### 2. 설계 순서
설계 순서는 정해진 것은 없지만, 저의 경우 다음과 같은 순서로 설계를 진행합니다.

1. **문제 이해**
   - 당연하지만 먼저 문제를 읽어야겠죠. 여기서 캐치해야 할 포인트는 문제 유형, 입력값의 범위 (시간 복잡도), 제약 조건 등입니다. 먼저 내가 이해한 문제의 내용과 중요해 보이는 포인트를 추려 종이에 적어놓습니다. 그림으로 정리하면 더 좋습니다.

2. **알고리즘 후보 추리기**
   - 문제를 이해했다면 사용 가능해 보이는 알고리즘을 정리해 후보군을 만들어 두면 좋습니다. 예를 들어 경우의 수 찾기? -> DFS, 최단경로 탐색? -> BFS, 아니면 또 다른 수학적 원리를 이용해야 하나? 이렇게 생각해볼 수 있습니다.
   - IM 시험에서는 DFS/BFS 문제는 잘 나오지 않고, A형 시험에서는 대부분 DFS/BFS 문제가 출제되므로, 이것도 하나의 단서로 활용할 수 있습니다.
https://pro.mincoding.co.kr/problem-step/22/level/141/detail/SAMSUNG_IM_09
LED 조명 제어
   - 예를 들어, IM 기출문제인 LED 조명 제어 문제를 살펴보면, 겉으로는 DFS로 경우의 수를 구해야 할 것처럼 보이지만, 실제로는 다른 규칙이 숨어 있었습니다. IM 문제라는 점에서 DFS는 아닐 것이라고 추측할 수 있었고, 입력값인 N이 100이 넘기 때문에 완전 탐색은 어려울 것이라고 예측할 수 있습니다. 
   - 조합/순열의 경우, 시간 복잡도는 O(N!)으로 N값이 10만 넘어가도 완전 탐색은 비효율적입니다. 그러므로 완전 탐색 알고리즘을 배제하고, 실제 코드를 구현하기 전에 스위치 작동 방식을 그림으로 그려보면 규칙을 찾을 수 있습니다. *다만 이때 주의할 점은, 사람은 당연하다고 생각하는 부분을 자기도 모르게 건너뛰기 때문에 구현할 때 빠뜨리지 않게 꼼꼼하게 체크하는 것이 중요합니다.*
```
예시)
N 이 5이고, 원하는 패턴이 1 1 0 0 1 일 때,
최초 상태
0 0 0 0 0   
1. 1번 조명 확인/ 패턴과 일치하지 않으니까 ON
1 1 1 1 1   
2. 2번 조명 확인 <- 2번은 현재 원하는 패턴과 일치하니까 pass
1 1 1 1 1   
3. 3번 조명 확인/ 패턴과 일치하지 않으니까 ON
1 1 0 1 1   
** 어? 규칙대로면 현재 번호보다 작은 번호의 스위치는 건드리지 않는구나**   
4. 4번 조명 확인/ 패턴과 일치하지 않으니까 ON
1 1 0 0 1   
4.5 패턴이 원하는 패턴과 일치한다, 반복문을 탈출하고 지금까지 얼마나 반복했는지 출력
```

https://pro.mincoding.co.kr/problem-step/20/level/130/detail/SAMSUNG_A_15 
하강 모의 실험
이 문제의 경우는 저번 A형 1번 문제였는데 복잡해 보이지만 실제로 문제를 찬찬히 읽어보면 수학적 테크닉이 필요하지도 않고, 경우의 수도 없는 단순하게 순차적으로 구현하면 되는 문제임을 알 수 있습니다.
입력값인 N 값도 최대가 500인데 N*N 크기의 배열을 다루는 문제이기 때문에 500*500 = 25만으로 O(N^2)보다 큰 시간복잡도 ex) O(N^3) 를 가진 풀이법을 고려할 필요가 없다는 것까지도 추론할 수 있습니다.
즉 원래 생각한 단순 구현이 정답일 가능성이 높다는 뜻이죠.

복잡하게 설명했는데 사실 IM, A형 수준에서는 IM이면 DFS,BFS 안쓰겠구나, A형이니까 문제 길고 입력값이 크면 오히려 쉬울 수도 있겠구나, N값이 10 미만으로 너무 작으면 완전탐색 문제구나 또는 완전탐색을 두번 돌려야 할 수도 있겠구나 등등의 간단한 추론을 해서 후보군을 좁혀나가시면 되겠습니다.


3. **반례 찾기**
   - 앞서 추린 후보들 중 가장 단순해 보이는 풀이법부터 검증을 시작합니다. 보통 A형 문제는 DFS/BFS 문제에서 제약 조건을 통해 조금씩 꼬아서 내기 때문에 제약 조건을 잘 읽고 내가 생각한 풀이에 반례가 없는지 확인해봐야 합니다.
https://pro.mincoding.co.kr/problem-step/20/level/130/detail/SAMSUNG_A_02
양봉업자 코코
   - 위 문제의 경우 DFS로 레벨4까지 조합을 구하는 방식을 바로 떠올릴 수 있습니다. 그러나 일반적인 DFS에서 [그림4]와 같은 모양을 탐색할 수 있는 방법이 있을까요? 이런 식으로 원래 생각한 풀이에서 반례를 찾았다면 반례에 대한 예외 처리를 하거나 알고리즘에 근본적인 문제가 있다면 다른 후보를 검증해 봐야 합니다.
해당 문제의 경우는 예외 처리로 풀이 가능하나 지나치게 반례가 많고 예외 처리를 끝도 없이 해줘야 한다면 근본적으로 풀이법이 잘못되었거나 훨씬 간단한 풀이법이 존재할 확률이 높습니다.

### 3. 구현 순서
설계를 마쳤다면 이제 구현할 차례입니다. 그러나 코딩 자체가 익숙하지 않아서 구현 과정에서 실수를 하거나 설계를 순간순간 까먹는 경우가 많습니다. 그래서 파이참을 켜고 구현할 때도 **주석을 통해 내가 코드를 어떻게 써내려갈 예정인지 한글로 미리 적어놓는 것이 좋습니다**. 그 후 디테일한 구현을 하고, 각각의 코드가 의도한 대로 작동하는지 검증해보면 좋습니다.

1. **의사 코드 작성**
   - 의사 코드는 알고리즘이 수행될 내용을 간단하게 설명한 것으로, 의사 코드 작성 자체가 어렵게 느껴지실 수 있지만 지금은 나만 알아볼 수 있으면 그만이기 때문에 어렵게 생각하지 말고 어느 위치에 뭘 만들지 대략적으로 적는다 생각하고 주석으로 써주시면 됩니다.
구현에 자신이 없을수록 실제 코드와 1대1 대응되도록 디테일한 부분까지 적어놓으시면 좋습니다.
예시
```
# DFS로 조합 탐색 구현
# 배열arr에서 N개를 뽑는 가능한 조합을 모두 출력하려고함, 단 중복 X

# DFS 함수 작성 (매개변수로 level을 받는다, 그리고 시작 노드도 받는다)
# level이 N과 같으면 리턴

# 반복문, 단 비중복 조합 탐색이기 때문에 현재 선택한 노드 다음부터 볼거임
# 중복됐는지 visited 배열로 확인하고
# 여기서 visited 배열 방문 처리 해주고 경로 저장 해줄거임
# dfs 재귀호출
# 리턴된 후에 visited, 경로 그 전 상태로 복구

# dfs 호출
```

2. **의사 코드를 보고 실제 구현 + 주석 달기**
   - 의사 코드를 보고 그대로 구현합니다. 코드를 작성하는 도중에도 주석을 꼼꼼하게 달아두면 중간에 실수를 하더라도 문제를 파악하기 쉬워집니다. 
예를 들어 이 변수는 내가 이런 의도로 선언했다, 또는 이 함수는 실제 의도대로 작동되는지 검증이 필요하다 등등 생각나는 대로 적어놓으시면 됩니다.
예시
```
# DFS로 조합 탐색 구현
# 배열arr에서 N개를 뽑는 가능한 조합을 모두 출력하려고함, 단 중복 X

# 경로를 저장할 리스트 path
path = []
arr = ['A','B','C']
# 방문한 노드인지 저장할 배열 visited
visited = [False] * len(arr)
N = int(input())

# DFS 함수 작성 (매개변수로 level을 받는다, 그리고 시작 노드도 받는다)
def dfs(level, stt):
    # level이 N과 같으면 리턴
    if level == N:
        print(path)
        return
    # 반복문, 단 비중복 조합 탐색이기 때문에 현재 선택한 노드 다음부터 볼거임
    for i in range(stt,len(arr)):
        # 중복됐는지 visited 배열로 확인하고
        if visited[i] == False:
            # 여기서 visited 배열 방문 처리 해주고 경로 저장 해줄거임
            visited[i] = True
            path.append(arr[i])
            # dfs 재귀호출
            dfs(level+1,i+1)
            # 리턴된 후에 visited, 경로 그 전 상태로 복구
            path.pop()
            visited[i] = False


# dfs 호출
dfs(0,0)
```

### 4. 디버깅 팁
설계를 꼼꼼하게 하고 주석을 열심히 달았어도 버그는 생길 수 있습니다. 이럴 때는 강사님이 알려주신 대로 디버거를 사용해서 디버깅을 잘 하시면 됩니다 하지만 간혹 디버깅이 비직관적일 때는, **디버거 + `print()` 로그를 활용**하는 것이 좋습니다. 예를 들어 2차원 배열 미로 탐색 문제에서 DFS 또는 BFS를 진입할 때마다 2차원 배열 전체를 출력해 실제 경로를 확인하는 방법이 있습니다.
https://pro.mincoding.co.kr/problem/G4LV29_5_%EC%9B%80%EC%A7%81%EC%9D%B4%EB%8A%94%EB%AA%AC%EC%8A%A4%ED%84%B0
움직이는 몬스터
아래는 위 문제를 디버깅하기 위해 ABC가 시간에 따라 실제로 어떻게 움직이는지 print로 뽑아본 예시입니다.
```
_A_
#_D
C_#
#__
second :  0
__A
#_D
C_#
#__
second :  0
__A
#_D
_C#
#__
second :  0
__A
#_D
_C#
#__
second :  1
__A
#_D
_C#
#__
second :  1
__A
#_D
__#
#C_
second :  1
__A
#_D
__#
#C_
second :  2
_A_
#_D
__#
#C_
second :  2
_A_
#_D
__#
#C_
second :  2
_A_
#D_
__#
#C_
second :  3
_A_
#D_
__#
#C_
second :  3
_A_
#D_
_C#
#__
second :  3
_A_
#D_
_C#
#__
second :  4
__A
#D_
_C#
#__
second :  4
__A
#D_
_C#
#__
second :  4
__A
#_D
_C#
#__
```

예시에서 의도대로 잘 움직이고 있음을 확인할 수 있습니다.
만일 문제가 있다면 로그를 확인해 어디서 어떤 문제가 발생했는지 바로 확인할 수 있을 것입니다.

### 5. DFS/BFS/DP 선택 기준
이건 저도 많이 헷갈리는 부분인데, IM 시험에서는 기본적으로 DFS/BFS 문제가 나오지 않으며, N값이 지나치게 크면 DP나 단순 구현 문제일 가능성이 높습니다. N값이 3~10 사이로 수상하게 작다면 DFS/BFS 완전 탐색 문제일 가능성이 높은데 파이썬은 재귀 성능이 좋지 않기 때문에 BFS를 우선 고려하고, 그다음에 DFS를 사용하는 것을 추천드립니다. BFS는 최단경로 탐색, Flood fill 문제 유형에 유리하고, DFS는 모든 노드를 방문해야 하거나 경로를 각각 저장할 필요가 있을 때 유리합니다.
그런데 A형 문제 수준에서는 그냥 둘다 써도 무방한 문제가 자주 출제된다고 하니 정 헷갈리면 그냥 익숙한걸로 푸시면 되겠습니다...

DP같은 경우는 매우 어렵지만 나오는 유형이 정해져 있는 편이라고 하니, DP예제를 몆가지 풀어보는게 답일 것 같습니다.

이상으로 제가 아는 선에서 알고리즘 꿀팁을 공유드렸습니다.
월요일 과목평가 2반 모두 잘 보셨으면 좋겠습니다!
참고로 저는 예비군가서 과목평가 안봅니다 모두 수고하세용~
